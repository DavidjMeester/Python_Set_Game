import os
import random
import pygame

# De eigenschappen opsplitsen
class Set:
    colors = ['red', 'green', 'purple']
    symbols = ['oval', 'squiggle', 'diamond']
    shadings = ['filled', 'shaded', 'empty']
    numbers = ['1', '2', '3']

    def __init__(self, name):
        self.name = name.lower()
        self.features = self.parse_name_to_features(self.name)

    def parse_name_to_features(self, name):
        color = next(i for i, c in enumerate(self.colors) if c in name)
        symbol = next(i for i, s in enumerate(self.symbols) if s in name)
        shading = next(i for i, sh in enumerate(self.shadings) if sh in name)
        number_char = name[-1]
        number = int(number_char) - 1
        return [color, symbol, shading, number]

    def __repr__(self):
        return str(self.features)

def is_set(card1,card2,card3):
        for x in range(4):
            totalvalue = card1[x] + card2[x] + card3[x]
            if totalvalue % 3 != 0:
                return False
        return True

def find_one_set(cards):
    cards_set = set(cards)
    def missing_card(c1, c2):
        return tuple((- (c1[x] + c2[x]) % 3) for x in range(4))
    for i in range(len(cards) - 2):
        for x in range(i + 1, len(cards) - 1):
            m = missing_card(cards[i], cards[x])
            if m in cards_set:
                return (cards[i], cards[x], m)

def find_all_sets(cards):
    cards_set = set(cards) 
    sets = set()
    def missing_card(c1, c2):
        return tuple((- (c1[x] + c2[x]) % 3) for x in range(4))
    for i in range(len(cards) - 2):
        for x in range(i + 1, len(cards) - 1):
            m = missing_card(cards[i], cards[x])
            if m in cards_set:
                SET = tuple(sorted((cards[i],cards[x],m)))
                sets.add(SET)
    return sets

def vervang_kaarten(geselecteerde_kaarten, kaarten, overgebleven_kaarten, kaart_pad):
    for kaart in geselecteerde_kaarten:
        if overgebleven_kaarten:
            nieuwe_bestandsnaam = random.choice(overgebleven_kaarten)
            overgebleven_kaarten.remove(nieuwe_bestandsnaam)
            pad = os.path.join(kaart_pad, nieuwe_bestandsnaam)
            kaart["image"] = pygame.image.load(pad)
            kaart["selected"] = False
            kaart["is_valid_set"] = None
            kaart["vector"] = tuple(Set(nieuwe_bestandsnaam.replace(".gif", "")).features)
        else:
            kaarten.remove(kaart)

#begin van pygame
pygame.init()
screen = pygame.display.set_mode((1080, 720))
clock = pygame.time.Clock()
running = True

#definities zodat we de kaarten kunnen zien 
kaart_pad = "kaarten"
alle_gif_kaarten = [f for f in os.listdir(kaart_pad) if f.endswith(".gif")]
gekozen_kaarten = random.sample(alle_gif_kaarten, 12)
overgebleven_kaarten = [f for f in alle_gif_kaarten if f not in gekozen_kaarten]

kaarten = []
for i, bestandsnaam in enumerate(gekozen_kaarten):
    pad = os.path.join(kaart_pad, bestandsnaam)
    afbeelding = pygame.image.load(pad)
    x = 50 + (i % 4) * 150
    y = 50 + (i // 4) * 215
    rect = pygame.Rect(x, y, 100, 200)
    kaarten.append({
        "image": afbeelding,
        "rect": rect,
        "selected": False,
        "vector": tuple(Set(bestandsnaam.replace(".gif", "")).features),
        "is_valid_set": None})

#definieer voor de loopjes en functies
set_timer = 0
ongeldige_set_timer = 0
set_gevonden_kaarten = []
ongeldige_set_kaarten = []
speler_score = 0
computer_score = 0


# Startscherm
def toon_startscherm():
    geselecteerde_moeilijkheid = None
    
    #tekst uitleg
    uitleg = [
        "Welcome to SET!",
        "",
        "The rules:",
        "- On the screen, you'll see 12 cards.",
        "- Each card has 4 properties:",
        "  color, shape, shading and number.",
        "- A set consist of 3 cards whose properties are:",
        "  either the same, or different for all 4 properties.",
        "",
        "Click on 3 cards to check if they form a set.",
        "",
        "Good Luck!"]

    #loop
    while True:
        screen.fill((180, 211, 178))

    #technische shit om die tekst en kelur te kunnen doen
        title_font = pygame.font.SysFont(None, 60)
        uitleg_font = pygame.font.SysFont(None, 30)

    # eigenschap van de startknop
        knop_rect_start = pygame.Rect(440, 590, 200, 60)
        knop_kleur = (70, 200, 70)
        tekst_kleur = (255, 255, 255)

        for i, regel in enumerate(uitleg):
            tekst = uitleg_font.render(regel, True, (255, 255, 255))
            screen.blit(tekst, (100, 150 + i * 30))

    #eigenschappen moeilijkheidsknoppen
        knop_kleur_beg = (255, 255, 0)
        knop_rect_beg = pygame.Rect(730, 185, 300, 70)

        knop_kleur_int = (255, 165, 0)
        knop_rect_int = pygame.Rect(730, 285, 300, 70)

        knop_kleur_exp = (255, 0, 0)
        knop_rect_exp = pygame.Rect(730, 385, 300, 70)
    
    #knoppen moeilijkheids
        pygame.draw.rect(screen, knop_kleur_beg, knop_rect_beg, border_radius = 10)
        pygame.draw.rect(screen, knop_kleur_int, knop_rect_int, border_radius = 10)
        pygame.draw.rect(screen, knop_kleur_exp, knop_rect_exp, border_radius = 10)

    #kleur aanpassen van de geselecteerde (0,0,0) is nog zwart maar misschien andere kleur?
        if geselecteerde_moeilijkheid == 40:
            knop_kleur_beg = (0, 0, 0)  
        pygame.draw.rect(screen, knop_kleur_beg, knop_rect_beg, border_radius = 12)
        if geselecteerde_moeilijkheid == 30:
            knop_kleur_int = (0,0,0)  
        pygame.draw.rect(screen, knop_kleur_int, knop_rect_int, border_radius = 12)
        if geselecteerde_moeilijkheid == 20:
            knop_kleur_exp = (0,0,0) 
        pygame.draw.rect(screen, knop_kleur_exp, knop_rect_exp, border_radius = 12)
            
    #het echte startscherm
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                exit()

            #het tikken van de knoppen
            if event.type == pygame.MOUSEBUTTONDOWN:
                if knop_rect_beg.collidepoint(event.pos):
                    geselecteerde_moeilijkheid = 40
                if knop_rect_int.collidepoint(event.pos):
                    geselecteerde_moeilijkheid = 30
                if knop_rect_exp.collidepoint(event.pos):
                    geselecteerde_moeilijkheid = 20
                if knop_rect_start.collidepoint(event.pos) and geselecteerde_moeilijkheid is not None:
                    return geselecteerde_moeilijkheid
       
       #start knop komt pas als je een moeilijkheidsknop hebt getikt
        if geselecteerde_moeilijkheid is not None:
            pygame.draw.rect(screen, knop_kleur, knop_rect_start, border_radius=10)
            knop_tekst = title_font.render("Start Set", True, tekst_kleur)
            screen.blit(knop_tekst, (450, 600))    
            
        # Titel op scherm 
        titel = title_font.render("SET - The Game", True, (255, 255, 255))
        screen.blit(titel, (screen.get_width() // 2 - titel.get_width() // 2, 40))
        
        # Tekst moeilijkheidsgraads
        knop_tekst_beg = title_font.render("Beginner", True, tekst_kleur)
        screen.blit(knop_tekst_beg, (750,200))

        knop_tekst_int = title_font.render("Intermediate", True, tekst_kleur)
        screen.blit(knop_tekst_int, (750, 300))

        knop_tekst_exp = title_font.render("Expert", True, tekst_kleur)
        screen.blit(knop_tekst_exp, (750, 400))
              
        pygame.display.flip()
        pygame.time.Clock().tick(60)


#eindscherm
def toon_eindscherm(speler_score, computer_score, huidige_tijd_per_beurt):
    knop_opnieuw = pygame.Rect(400, 450, 280, 60)
    knop_minder_tijd = pygame.Rect(400, 530, 130, 50)
    knop_meer_tijd = pygame.Rect(550, 530, 130, 50)

    font_groot = pygame.font.SysFont(None, 64)
    font_klein = pygame.font.SysFont(None, 36)

    #wie er wint
    if speler_score > computer_score:
            winnaar = "You win!" 
    elif speler_score < computer_score:
            winnaar = "Computer wins!"
    else:
        winnaar = "Tie!"

    #als je het scherm hebt-loop
    while True:
        screen.fill((0, 30, 60))

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                exit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if knop_opnieuw.collidepoint(event.pos):
                    return huidige_tijd_per_beurt  #Start opnieuw met huidge tijd
                elif knop_meer_tijd.collidepoint(event.pos):
                    huidige_tijd_per_beurt += 5
                elif knop_minder_tijd.collidepoint(event.pos) and huidige_tijd_per_beurt > 5:
                    huidige_tijd_per_beurt -= 5

        #Titel & winnaar
        text_winnaar = font_groot.render("Game over!", True, (255, 255, 255))
        screen.blit(text_winnaar, (screen.get_width() // 2 - text_winnaar.get_width() // 2, 80))
        
        uitslag = font_klein.render(winnaar, True, (255, 255, 255))
        screen.blit(uitslag, (screen.get_width() // 2 - uitslag.get_width() // 2, 160))

        score_text = font_klein.render(f"Player: {speler_score}    Computer: {computer_score}", True, (255, 255, 255))
        screen.blit(score_text, (screen.get_width() // 2 - score_text.get_width() // 2, 220))

        tijd_text = font_klein.render(f"Time per turn: {huidige_tijd_per_beurt} seconds", True, (255, 255, 255))
        screen.blit(tijd_text, (screen.get_width() // 2 - tijd_text.get_width() // 2, 270))

        # Knoppen tekenen
        pygame.draw.rect(screen, (0, 180, 0), knop_opnieuw, border_radius=10)
        pygame.draw.rect(screen, (180, 0, 0), knop_minder_tijd, border_radius=10)
        pygame.draw.rect(screen, (0, 0, 180), knop_meer_tijd, border_radius=10)

        opnieuw_text = font_klein.render("Play again", True, (255, 255, 255))
        screen.blit(opnieuw_text, (knop_opnieuw.centerx - opnieuw_text.get_width() // 2,
                                   knop_opnieuw.centery - opnieuw_text.get_height() // 2))

        minder_text = font_klein.render("-5 sec", True, (255, 255, 255))
        screen.blit(minder_text, (knop_minder_tijd.centerx - minder_text.get_width() // 2,
                                  knop_minder_tijd.centery - minder_text.get_height() // 2))

        meer_text = font_klein.render("+5 sec", True, (255, 255, 255))
        screen.blit(meer_text, (knop_meer_tijd.centerx - meer_text.get_width() // 2,
                                knop_meer_tijd.centery - meer_text.get_height() // 2))

        pygame.display.flip()
        pygame.time.Clock().tick(60)

#van deze volgorgde klopt echt nog niks!!

#dit is voor het spel zelf
font = pygame.font.SysFont(None, 48)
COUNTDOWN_SECONDS = toon_startscherm()
endtime = pygame.time.get_ticks() + COUNTDOWN_SECONDS * 1000

while running:
    #timer
    remaining_ms = endtime - pygame.time.get_ticks()
    remaining_seconds = max(0, remaining_ms // 1000)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        #kaarten tikken en zodra je 3 hebt geselecteerd functie aanroepen en score updaten maar wel nog zonder die highlight ronde 
        #erom heen en ook nog niet het plaatje
        elif event.type == pygame.MOUSEBUTTONDOWN:
            for kaart in kaarten:
                if kaart["rect"].collidepoint(event.pos):
                    kaart["selected"] = not kaart["selected"]

            geselecteerd = [k for k in kaarten if k["selected"]]
            if len(geselecteerd) == 3:
                vectors = [k["vector"] for k in geselecteerd]
                is_geldig = is_set(*vectors)
                for k in geselecteerd:
                    k["is_valid_set"] = is_geldig
                if is_geldig:
                    set_door_player = True
                    speler_score += 1
                    set_timer = pygame.time.get_ticks() + 500
                    set_gevonden_kaarten = geselecteerd.copy()
                    endtime = pygame.time.get_ticks() + COUNTDOWN_SECONDS * 1000
                else:
                    ongeldige_set_timer = pygame.time.get_ticks() + 500
                    ongeldige_set_kaarten = geselecteerd.copy()
            else:
                for k in kaarten:
                    k["is_valid_set"] = None

    screen.fill((30, 100, 100))

    for kaart in kaarten:
        screen.blit(kaart["image"], kaart["rect"].topleft)
        if kaart["selected"]:
            if kaart["is_valid_set"] is True:
                kleur = (0, 255, 0)
                if set_door_player == True:
                    surfacegoed = pygame.image.load(os.path.join("goeie set foto.jpg"))
                else: 
                    surfacegoed = pygame.image.load(os.path.join("computer set goed.webp"))
                    surfacegoed = pygame.transform.scale(surfacegoed, (200, 355))
                screen.blit(surfacegoed, (725, 300))
            elif kaart["is_valid_set"] is False:
                kleur = (255, 0, 0)
                surfacefout = pygame.image.load(os.path.join("foute set foto.jpg"))
                screen.blit(surfacefout, (725, 300))
            else:
                kleur = (255, 255, 0)
            pygame.draw.rect(screen, kleur, kaart["rect"], 4)

    if set_timer and pygame.time.get_ticks() >= set_timer:
        vervang_kaarten(set_gevonden_kaarten, kaarten, overgebleven_kaarten, kaart_pad)
        set_gevonden_kaarten.clear()
        set_timer = 0

    if ongeldige_set_timer and pygame.time.get_ticks() >= ongeldige_set_timer:
        for kaart in ongeldige_set_kaarten:
            kaart["selected"] = False
            kaart["is_valid_set"] = None
        ongeldige_set_kaarten.clear()
        ongeldige_set_timer = 0

#als de tijd op is moet de computer kijken hoe die een set kan vinden met find_one_set en dan nieuwe kaarten 
    if remaining_seconds == 0:
        geselecteerd = []
        huidige_vectors = [k["vector"] for k in kaarten if "vector" in k]
        gevonden_set = find_one_set(huidige_vectors)
        show_gemiste_sets_start = pygame.time.get_ticks()
        show_gemiste_sets_end = show_gemiste_sets_start + 1300
        if gevonden_set:
            set_door_player = False
            computer_score += 1
            if len(find_all_sets(huidige_vectors)) == 1:
                gemiste_sets = "You missed 1 SET!"
            else:
                gemiste_sets = f"You missed {len(find_all_sets(huidige_vectors))} SETS!"
            set_kaarten = [k for k in kaarten if k["vector"] in gevonden_set]
            for kaart in kaarten:
                kaart["selected"] = kaart in set_kaarten
                kaart["is_valid_set"] = kaart in set_kaarten
            set_timer = pygame.time.get_ticks() + 1300
            set_gevonden_kaarten = set_kaarten.copy()
        # geen mogelijke set optie
        else:
            te_vervangen_kaarten = [kaarten[i] for i in [0, 4, 8] if i < len(kaarten)]
            gemiste_sets = "There were no SETS!"
            vervang_kaarten(te_vervangen_kaarten, kaarten, overgebleven_kaarten, kaart_pad)
        gemiste_sets_text = font.render(gemiste_sets, True, (255, 255, 255))  
        endtime = pygame.time.get_ticks() + COUNTDOWN_SECONDS * 1000

        # Spel is klaar als er geen sets meer zijn en geen overgebleven_kaarten
    huidige_vectors = [k["vector"] for k in kaarten]
    if not find_one_set(huidige_vectors) and not overgebleven_kaarten:
        COUNTDOWN_SECONDS = toon_eindscherm(speler_score, computer_score, COUNTDOWN_SECONDS)

    #uhhhh waarvoor is deze nog? zijn die nog voor het laden van de kaarten?
        gekozen_kaarten = random.sample(alle_gif_kaarten, 12)
        overgebleven_kaarten = [f for f in alle_gif_kaarten if f not in gekozen_kaarten]
        kaarten.clear()
        for i, bestandsnaam in enumerate(gekozen_kaarten):
            pad = os.path.join(kaart_pad, bestandsnaam)
            afbeelding = pygame.image.load(pad)
            x = 50 + (i % 4) * 150
            y = 50 + (i // 4) * 215
            rect = pygame.Rect(x, y, 100, 200)
            kaarten.append({
                "image": afbeelding,
                "rect": rect,
                "selected": False,
                "vector": tuple(Set(bestandsnaam.replace(".gif", "")).features),
                "is_valid_set": None})
        speler_score = 0
        computer_score = 0
        endtime = pygame.time.get_ticks() + COUNTDOWN_SECONDS * 1000


#tekst aan de zijkant, rechts
    pygame.draw.line(screen, (255, 255, 255), (660, 0), (660, 720), 15)
    timer_text = font.render(f"Time left: {remaining_seconds}s", True, (255, 255, 255))
    screen.blit(timer_text, (675, 20))
    score_text = font.render(f"You: {speler_score}  |  Computer: {computer_score}", True, (255, 255, 255))
    screen.blit(score_text, (675, 70))
    pot_text = font.render(f"Cards left: {len(overgebleven_kaarten)}", True, (255, 255, 255))
    screen.blit(pot_text, (675, 120))
    if 'show_gemiste_sets_end' in locals() and pygame.time.get_ticks() < show_gemiste_sets_end:
        screen.blit(gemiste_sets_text, (675, 200))


    pygame.display.flip()
    clock.tick(60)

pygame.quit()


